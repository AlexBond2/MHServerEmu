# Game Data Overview

Marvel Heroes uses a completely custom game simulation layer developed by Gazillion. It interfaces with Unreal Engine in the client, but it can also function independently from it. This layer handles all game logic, and it also manages all game data.

Static data includes things needed to run the game, such as loot tables, damage calculation formulas, enemy placements, AI presets, and much more. This data is mirrored between the client and the server, and it is managed at runtime by the `GameDatabase` singleton class. The data is stored on disk in so-called pak files that you can read more about [here](./PakFile.md).

A piece of static data is called a *prototype*. A prototype can be as small as a variable in a damage calculation formula to as large as a definition for a region or a playable hero. Each prototype is a bound to a specific class that encapsulates it and postprocesses it after loading if needed.

Prototypes can be separated into two main categories: [Calligraphy](./Calligraphy.md) prototypes stored in `Calligraphy.sip` and [resource](./Resources.md) prototypes stored in `mu_cdata.sip`. Only cells, districts, encounters, props, prop sets, and UIs are resource prototypes, everything else (which is the vast majority of it) is Calligraphy-based.

In addition to prototypes there are also auxiliary Calligraphy data types that are used as prototype field values: curves, assets, and blueprints.

## Data References

There are two kinds of identifiers that can be used to reference pieces of static data: id and GUID.

A data id is a 64-bit hash derived from the file path. Since it changes when a file is moved or renamed, the same data can have different ids in different versions of the game. The client encapsulates data ids in DataRef structs, and in some places id and data ref are used interchangeably.

GUID is also a 64-bit value, but unlike a data id, it never changes for a piece of data. Ids are generally used for client <-> server communication instead of full file paths, while GUIDs are used for storing persistent data, such as player mission progress. Resource prototypes do not have a GUID, and every time a "resource GUID" is mentioned in the code it actually refers to its name.

Calligraphy data references are stored in `.directory` files, while resource references are generated during `GameDatabase` initialization. 

Prototype ids are generated by hashing the file path with a combination of [Adler-32](https://en.wikipedia.org/wiki/Adler-32) and [CRC-32](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) algorithms:

```csharp
string path;
path = path.ToLower();
ulong prototypeId = (Adler32(path) | (Crc32(path) << 32)) - 1
```

Before hashing, Calligraphy and resource prototype paths undergo different preparation.

For Calligraphy prototypes:

1. Take the relative path (without `Calligraphy/`).

2. Replace `.` characters with `?`.

3. Replace `/` characters with `.`.

For resource prototypes:

1. Take the full path.

2. Insert `&` as the first character.

The hashing algorithms for GUIDs and other data types are currently unknown.
